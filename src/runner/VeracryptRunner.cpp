//  Licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 2.1. See License in the project root for license information.
#include "VeracryptRunner.h"

#include <QDBusConnection>
#include <QDBusArgument>
#include <QDBusMetaType>
#include <QDebug>
#include <core/VolumeCommandBuilder.h>
#include <ui/VeracryptConfigItem.h>
#include <QtWidgets/QGridLayout>

// Generated by qt5_add_dbus_adaptor command im CMakeLists.txt file
#include "krunner1adaptor.h"
#include "ui/editdialog.h"

/**
 * TODO Issue regarding KDE Window system integration
 * TODO Command line interface
 * TODO Add Dependencies/Screenshots
 *
 */
VeracryptRunner::VeracryptRunner() {
    new Krunner1Adaptor(this);
    qDBusRegisterMetaType<RemoteMatch>();
    qDBusRegisterMetaType<RemoteMatches>();
    qDBusRegisterMetaType<RemoteAction>();
    qDBusRegisterMetaType<RemoteActions>();
    QDBusConnection::sessionBus().registerService(QStringLiteral("net.veracryptrunner2"));
    QDBusConnection::sessionBus().registerObject(QStringLiteral("/veracryptrunner"), this);

    RemoteAction action;
    action.id = QStringLiteral("exit");
    action.text = QStringLiteral("Edit Entry");
    action.iconName = QStringLiteral("documentinfo");
    actions = RemoteActions({action});
}

VeracryptRunner::~VeracryptRunner() {
    qDeleteAll(volumes);
    delete watcher;
    delete manager;
}

void VeracryptRunner::init() {
    initialized = true;
    manager = new VeracryptVolumeManager();
    loadVolumesFromConfig();
    watcher = new QFileSystemWatcher();
    watcher->addPath(QDir::homePath() % QStringLiteral("/.config/veracryptrunnerrc"));
    connect(watcher, &QFileSystemWatcher::fileChanged, this, &VeracryptRunner::configChanged);
}

RemoteMatches VeracryptRunner::Match(const QString &searchTerm) {
    RemoteMatches ms;
    if (!searchTerm.contains(queryRegex)) {
        return ms;
    }
    if (!initialized) init();

    // When the fetch is forced or the last fetch is too old they get refetched
    // With this the volumes are only fetched if the user wants to specifically query this plugin
    // and they can be reused for multiple queries
    QTime current = QTime::currentTime();
    if (forceFetch || lastFetched.secsTo(current) > 10) {
        forceFetch = false;
        lastFetched = current;
        fetchMountedVolumes();
    }
    queryRegex.indexIn(searchTerm);
    const QString volumeQuery = queryRegex.cap(1);
    for (const auto *volume:volumes) {
        if (volume->name.contains(volumeQuery, Qt::CaseInsensitive)) {
            RemoteMatch m;
            if (!mountedVolumes.contains(volume->source)) {
                m.id = QStringLiteral("mount|") % volume->name;
                m.text = QStringLiteral("Mount Volume: ") % volume->name;
                m.relevance = (float) volume->priority / 100;
            } else {
                m.id = QStringLiteral("unmount|") % volume->name;
                m.text = QStringLiteral("Unount Volume: ") % volume->name;
                m.relevance = 0;
            }
            m.iconName = iconName;
            m.type = Plasma::QueryMatch::ExactMatch;
            ms.append(m);
        }
    }
    return ms;

}

RemoteActions VeracryptRunner::Actions() {
    return actions;
}

void VeracryptRunner::Run(const QString &id, const QString &actionId) {
    Q_UNUSED(actionId)

    const int idx = id.indexOf('|');
    const auto action = QStringRef(&id, 0, idx);
    VeracryptVolume *volume = volumes.value(id.mid(idx + 1));

    if (actionId.isEmpty()) {
        if (action == QLatin1String("mount")) {
            QTimer::singleShot(0, [volume]() -> void {
                VolumeCommandBuilder::buildMountCommand(volume);
            });
        } else {
            VolumeCommandBuilder::buildUnmountCommand(volume);
        }
        forceFetch = true;
    } else {
        EditDialog dialog(volume, volumes.keys());
        dialog.exec();
        dialog.deleteLater();
    }
}

void VeracryptRunner::fetchMountedVolumes() {
    mountedVolumes.clear();
    QProcess fetchVolumesProcess;
    fetchVolumesProcess.start(QStringLiteral("veracrypt"),
                              QStringList() << QStringLiteral("-t") << QStringLiteral("-l"));
    fetchVolumesProcess.waitForFinished(-1);
    const QString res = fetchVolumesProcess.readAll();
    if (!res.isEmpty()) {
        for (const auto &mountedVolume:res.split("\n")) {
            QRegExp pathRegex(QStringLiteral(R"(\d*: ([^ ]+))"));
            pathRegex.indexIn(mountedVolume);
            const auto path = pathRegex.cap(1);
            if (!path.isEmpty()) {
                mountedVolumes.append(path);
            }
        }
    }
}

void VeracryptRunner::configChanged(const QString &fileName) {
    loadVolumesFromConfig();
    watcher->addPath(fileName);
}

void VeracryptRunner::loadVolumesFromConfig() {
    if (!volumes.isEmpty()) {
        qDeleteAll(volumes);
    }
    volumes = manager->getVeracryptVolumesMap();
}
