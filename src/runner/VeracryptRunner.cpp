//  Licensed under the GNU LESSER GENERAL PUBLIC LICENSE Version 2.1. See License in the project root for license information.
#include "VeracryptRunner.h"

#include <QDBusArgument>
#include <QDBusConnection>
#include <QDBusMetaType>
#include <QDebug>
#include <QGridLayout>
#include <ui/VeracryptConfigItem.h>

// Generated by qt5_add_dbus_adaptor command im CMakeLists.txt file
#include "krunner1adaptor.h"
#include "ui/editdialog.h"

/**
 * TODO Issue regarding KDE Window system integration
 * TODO Command line interface
 *
 */
VeracryptRunner::VeracryptRunner()
{
    new Krunner1Adaptor(this);
    qDBusRegisterMetaType<RemoteMatch>();
    qDBusRegisterMetaType<RemoteMatches>();
    qDBusRegisterMetaType<RemoteAction>();
    qDBusRegisterMetaType<RemoteActions>();
    QDBusConnection::sessionBus().registerService(QStringLiteral("net.veracryptrunner2"));
    QDBusConnection::sessionBus().registerObject(QStringLiteral("/veracryptrunner"), this);

    RemoteAction action;
    action.id = QStringLiteral("exit");
    action.text = QStringLiteral("Edit Entry");
    action.iconName = QStringLiteral("document-edit");
    actions = RemoteActions({action});
}

VeracryptRunner::~VeracryptRunner()
{
    qDeleteAll(volumes);
    delete watcher;
    delete manager;
}

void VeracryptRunner::init()
{
    initialized = true;
    manager = new VeracryptVolumeManager();
    loadVolumesFromConfig();
    watcher = new QFileSystemWatcher();
    watcher->addPath(QDir::homePath() % QStringLiteral("/.config/veracryptrunnerrc"));
    connect(watcher, &QFileSystemWatcher::fileChanged, this, &VeracryptRunner::configChanged);
}

RemoteMatches VeracryptRunner::Match(const QString &searchTerm)
{
    RemoteMatches ms;
    if (!searchTerm.contains(queryRegex)) {
        return ms;
    }
    if (!initialized)
        init();

    // When the fetch is forced or the last fetch is too old they get refetched
    // With this the volumes are only fetched if the user wants to specifically query this plugin
    // and they can be reused for multiple queries
    QTime current = QTime::currentTime();
    if (forceFetch || lastFetched.secsTo(current) > 10) {
        forceFetch = false;
        lastFetched = current;
        manager->fetchMountedVolumes(mountedVolumes);
    }
    const QRegularExpressionMatch match = queryRegex.match(searchTerm);
    const QString volumeQuery = match.lastCapturedIndex() < 1 ? QString() : match.capturedTexts().at(1);
    for (const auto *volume : volumes) {
        if (volume->name.contains(volumeQuery, Qt::CaseInsensitive)) {
            RemoteMatch m;
            if (!mountedVolumes.contains(volume->source)) {
                m.id = QStringLiteral("mount|") % volume->name;
                m.text = QStringLiteral("Mount Volume: ") % volume->name;
                m.relevance = (float)volume->priority / 100;
            } else {
                m.id = QStringLiteral("unmount|") % volume->name;
                m.text = QStringLiteral("Unount Volume: ") % volume->name;
                m.relevance = 0;
            }
            m.iconName = iconName;
            m.type = Type::ExactMatch;
            ms.append(m);
        }
    }
    return ms;
}

RemoteActions VeracryptRunner::Actions()
{
    return actions;
}

void VeracryptRunner::Run(const QString &id, const QString &actionId)
{
    const int idx = id.indexOf('|');
    const QString action = id.mid(0, idx);
    VeracryptVolume *volume = volumes.value(id.mid(idx + 1));

    if (actionId.isEmpty()) {
        if (action == QLatin1String("mount")) {
            QTimer::singleShot(0, [volume]() -> void {
                VolumeCommandBuilder::buildMountCommand(volume);
            });
        } else {
            VolumeCommandBuilder::buildUnmountCommand(volume);
        }
        forceFetch = true;
    } else {
        EditDialog dialog(volume, volumes.keys());
        dialog.exec();
        dialog.deleteLater();
    }
}

void VeracryptRunner::configChanged(const QString &fileName)
{
    loadVolumesFromConfig();
    watcher->addPath(fileName);
}

void VeracryptRunner::loadVolumesFromConfig()
{
    if (!volumes.isEmpty()) {
        qDeleteAll(volumes);
    }
    volumes = manager->getVeracryptVolumesMap();
}

#include "moc_VeracryptRunner.cpp"
